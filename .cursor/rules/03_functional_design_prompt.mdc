# 汎用的機能詳細設計プロンプト

| 版数 | 日付 | 作成者 | 変更内容 |
| ---- | ---- | ----- | ------- |
| 2.1  | 2024年12月26日 | (AI) | 情報不足時の人間判断委任対応追加 |
| 2.0  | 2024年12月26日 | (AI) | 汎用化改訂版（技術スタック非依存） |
| 1.0  | YYYY年MM月DD日 | (AI) | 初版作成   |

### 目次
0. 設計前情報確認
1. 機能概要・設計前提
2. アーキテクチャ適応設計
3. 処理フロー設計
4. データフロー設計
5. モジュール・コンポーネント設計
6. インターフェース設計
7. エラーハンドリング設計
8. 性能・セキュリティ設計
9. テスト設計
10. 実装ガイドライン

---

## 0. 設計前情報確認

### 0.1. 必要情報チェックリスト

#### 基本要件確認
```
設計開始前の必須確認項目:

□ 要件定義書が存在し、以下が明記されている
  □ 機能ID・機能名が明確
  □ 機能概要・目的が明記
  □ 入力仕様が詳細化
  □ 出力仕様が詳細化
  □ 処理概要・業務フローが明記
  □ 機能要件・非機能要件が明確
  □ ユーザーストーリー・ユースケースが明記

□ アーキテクチャ設計書が存在し、以下が明記されている
  □ 技術スタックが選定済み
  □ アーキテクチャパターンが決定済み
  □ デプロイ構成が明確
  □ 外部システム連携方針が明確
  □ データベース・データ設計が明確

□ データモデル設計書が存在し、以下が明記されている
  □ 関連テーブル・エンティティが明確
  □ 必要なフィールド・属性が明確
  □ データ関連・制約が明確
  □ バリデーション・ビジネスルールが明確
```

### 0.2. 情報不足時の対応フロー

```
IF 上記チェックリストで不足項目がある場合 THEN
    ❌ 自動的に設計を進めず、以下の手順で人間に判断を委ねる:
    
    Step 1: 不足情報の明確化・報告
    ├── 不足している具体的な情報項目をリスト化
    ├── 各不足項目が設計に与える影響度を評価
    ├── 設計継続の可否判断に必要な最低限情報を明確化
    └── 現在利用可能な情報と不足情報を整理して報告
    
    Step 2: 人間への判断委任
    ├── 「以下の情報が不足しており、設計を進められません」と明示
    ├── 「どのように進めるかご指示ください」と明確に質問
    ├── 以下の選択肢を提示:
    │   □ 不足情報の調査・収集を指示する
    │   □ 利用可能な情報のみで設計を進める（リスクあり）
    │   □ 特定の仮定・制約条件下での設計を進める
    │   □ 設計を一時中断し、情報収集完了後に再開
    └── 人間からの明確な指示・承認を待つ
    
    Step 3: 指示に従った対応実行
    ├── IF 調査指示がある場合 THEN 指定された範囲で調査実行
    ├── IF 限定設計指示がある場合 THEN リスク明記の上で設計実行
    ├── IF 仮定条件指示がある場合 THEN 仮定を明記して設計実行
    └── IF 中断指示がある場合 THEN 設計を中断

ELSE IF 全情報が揃っている場合 THEN
    直接機能設計を開始
    
END IF

⚠️ 重要: AIが独自判断で仮定・推測・調査を進めることは禁止
必ず人間の明確な指示・承認を得てから次のステップに進むこと
```

### 0.3. 情報不足時の判断指針

#### 設計継続不可能レベル（人間の判断必須）
```
🚨 以下の場合は設計を進めず、必ず人間に報告・相談:

□ 業務要件・機能要件が不明確
  ├── 機能の目的・ゴールが不明
  ├── 入力・出力仕様が不明確
  ├── 業務フロー・処理順序が不明
  └── → 「機能要件が不明確で設計できません。要件定義の確認が必要です。」

□ 技術仕様・アーキテクチャが不明確  
  ├── 使用技術スタックが未選定
  ├── アーキテクチャパターンが未決定
  ├── デプロイ・実行環境が不明
  └── → 「技術仕様が不明確で設計できません。アーキテクチャ設計の確認が必要です。」

□ データ設計・外部連携仕様が不明確
  ├── 必要なデータ項目・構造が不明
  ├── 外部API・システム仕様が不明
  ├── データベーススキーマが不明
  └── → 「データ設計が不明確で設計できません。データモデル設計の確認が必要です。」
```

#### 部分的情報不足レベル（人間の判断で継続可否決定）
```
⚠️ 以下の場合は人間に判断を委ね、指示に従って対応:

□ 詳細仕様・エッジケースが不明確
  ├── 例外処理・エラーケース詳細が不明
  ├── パフォーマンス・制約詳細が不明
  ├── UIデザイン・ユーザビリティ詳細が不明
  └── → 「詳細仕様が不明確です。類似機能調査または仮定での設計継続をどうしますか？」

□ 非機能要件・品質要件が不明確
  ├── 性能要件・レスポンス時間が不明
  ├── セキュリティ要件詳細が不明
  ├── 可用性・信頼性要件が不明
  └── → 「非機能要件が不明確です。業界標準適用または要件確認をどうしますか？」

□ テスト要件・運用要件が不明確
  ├── テスト項目・カバレッジ基準が不明
  ├── 運用監視・ログ要件が不明
  ├── デプロイ・リリース手順が不明
  └── → 「テスト・運用要件が不明確です。プロジェクト標準適用をどうしますか？」
```

#### 人間への報告テンプレート
```
❌ 設計継続不可：以下の重要情報が不足しています

【不足している情報】
- [具体的な不足項目をリスト化]

【設計への影響】
- [各不足項目が設計に与える影響を説明]

【推奨対応】
- [情報収集・確認が必要な具体的事項]

【選択肢】
□ 不足情報の調査・収集を指示
□ 特定条件・仮定での限定設計継続
□ 設計を中断し、情報収集完了後に再開

どのように進めるかご指示ください。
```

### 0.4. 人間の指示に基づく調査手順

#### 人間から調査指示を受けた場合の実行手順
```
IF 人間から「情報調査を実行してください」と明確な指示がある場合のみ実行:

Phase 1: ドキュメント調査（指示された範囲のみ）
├── 指定されたドキュメント・ファイルの詳細確認
├── 指定された機能・キーワードでの検索
├── 指定された関連機能・類似機能の調査
└── 調査結果を人間に報告・確認を求める

Phase 2: コードベース調査（既存プロジェクト・指示がある場合のみ）
├── 指定された機能・パターンの実装調査
├── 指定されたファイル・モジュールの構成確認
├── 指定された設計パターン・標準の確認
└── 調査結果を人間に報告・次の指示を求める

Phase 3: 調査結果報告・次指示待ち
├── 「調査を完了しました」と明確に報告
├── 発見した情報・まだ不明な点を整理して報告
├── 「この情報で設計を進めますか？」と確認
└── 人間からの次の指示を待つ

⚠️ 重要: 人間からの明確な調査指示がない限り、勝手に調査は実行しない
```

#### 調査実行時の注意事項
```
□ 調査範囲は人間が指定した範囲に厳密に限定
□ 調査中に新たな疑問・不明点が発見された場合は人間に報告
□ 調査結果に基づく設計判断・仮定は人間の承認なしに実行しない
□ 「調査で○○がわかりました。××は依然不明です。どうしますか？」形式で報告
```

#### 調査報告テンプレート
```
🔍 調査完了報告

【調査対象】
- [指示された調査範囲・対象]

【判明した情報】
- [発見・確認できた具体的情報]

【依然不明な情報】  
- [調査しても判明しなかった項目]

【設計への影響】
- [判明した情報が設計に与える影響]

【次のステップ】
この情報で設計を進めるか、追加調査が必要かご指示ください。
```

### 0.5. 人間の承認による設計継続方法

#### 人間から設計継続承認を得た場合の記載方法
```
IF 人間から「仮定・制約条件で設計を継続してください」と明確な承認がある場合のみ実行:

設計書内で人間承認済み事項を明記する方法:

【人間承認済み事項】セクション（必須）
├── 承認日時・承認者
├── 承認された仮定・制約条件
├── 承認された設計継続範囲
└── 承認時の条件・留意事項

【要確認事項】セクション（必須）
├── 機能仕様で依然不明確な点
├── 技術仕様で未決定な点  
├── 外部連携で確認が必要な点
├── 性能・セキュリティで確認が必要な点
└── 運用・保守で確認が必要な点

【承認済み仮定条件】セクション（必須）
├── 人間が承認した仮定（根拠含む）
├── 業界標準・ベストプラクティス適用（承認済み）
├── 類似機能からの類推（承認済み）
├── 技術制約に基づく仮定（承認済み）
└── プロジェクト標準適用（承認済み）

【制約・前提条件】セクション
├── 技術的制約（フレームワーク・ライブラリ）
├── 業務的制約（運用ルール・承認フロー）
├── 外部システム制約（API仕様・データ形式）
├── 性能制約（レスポンス時間・スループット）
└── セキュリティ制約（認証・認可・暗号化）

【リスク・懸念事項】セクション（必須）
├── 仮定が間違っていた場合の影響（リスク評価）
├── 外部システム変更のリスク
├── 性能・スケーラビリティのリスク
├── セキュリティ・データ整合性のリスク
└── 運用・保守上のリスク

⚠️ 注意: 人間の明確な承認なしに仮定・制約での設計継続は禁止
```

#### 承認範囲の段階的設計アプローチ
```
IF 人間から段階的設計の承認がある場合のみ実行:
    
    Stage 1: 確定情報ベースでの基本設計（承認済み範囲のみ）
    ├── 人間が確認・承認した要件での基本機能設計
    ├── 人間が承認した技術選択・アーキテクチャの基本設計  
    ├── 人間が確認した明確なデータモデル・API設計
    └── 人間が承認した基本的なエラーハンドリング設計
    
    Stage 2: 承認済み仮定ベースでの詳細設計
    ├── 人間が承認した仮定での詳細機能設計
    ├── 人間が承認した想定ケースでの処理フロー設計
    ├── 人間が承認した標準的パターンでの実装設計
    └── 人間が承認した品質基準での品質設計
    
    Stage 3: 確認後の設計調整・更新（承認必須）
    ├── 要確認事項の確認結果を人間に報告
    ├── 仮定の検証・修正を人間に報告・承認依頼
    ├── 追加要件の設計組み込みを人間に確認・承認依頼
    └── リスク対策の具体化を人間に報告・承認依頼

各Stageの完了時に必ず人間に報告・次Stage承認を求める
END IF
```

#### 人間承認依頼テンプレート
```
📋 設計継続承認依頼

【現在の状況】
- [情報不足・不明確事項の整理]

【提案する設計継続方法】
- [仮定・制約条件での設計継続提案]

【設定する仮定・制約】
- [具体的な仮定・制約条件]

【想定されるリスク】
- [仮定が間違っていた場合の影響]

【承認をお願いする事項】
□ 上記仮定・制約での設計継続
□ 段階的設計アプローチの採用
□ 定期的な進捗報告・承認確認

この条件で設計を継続してもよろしいでしょうか？
```

## 1. 機能概要・設計前提

### 1.1. 機能概要
**要件定義書からの機能詳細**:
- **機能ID**: [要件定義書の機能ID]
- **機能名**: [要件定義書の機能名]
- **機能概要**: [要件定義書の機能概要]
- **入力**: [要件定義書の入力仕様]
- **出力**: [要件定義書の出力仕様]
- **処理概要**: [要件定義書の処理概要]

**アーキテクチャ設計書からの技術前提**:
- **技術スタック**: [アーキテクチャ設計書の技術選定]
- **アーキテクチャパターン**: [アーキテクチャ設計書の設計パターン]
- **デプロイ構成**: [アーキテクチャ設計書のデプロイメント]
- **外部連携**: [アーキテクチャ設計書の外部システム連携]

### 1.2. 機能分類・実装範囲

#### アプリケーション種別による分類
```
分類判定フロー:
1. アーキテクチャ設計書でアプリケーション種別を確認
2. 該当する機能分割方針を適用
3. 技術スタックに応じた実装構造を決定
```

**Webアプリケーション（フロントエンド + バックエンド）**:
```
機能分割方針:
├── フロントエンド層
│   ├── ユーザーインターフェース
│   ├── クライアント状態管理
│   └── サーバー通信処理
├── バックエンド層  
│   ├── API層（エンドポイント定義）
│   ├── ビジネスロジック層
│   └── データアクセス層
└── 共通層
    ├── 認証・認可
    ├── バリデーション
    └── エラーハンドリング
```

**APIサービス・マイクロサービス**:
```
機能分割方針:
├── API層
│   ├── エンドポイント定義
│   ├── リクエスト・レスポンス処理
│   └── 認証・認可
├── ビジネスロジック層
│   ├── ドメインサービス
│   ├── ユースケース実装
│   └── ビジネスルール
├── データアクセス層
│   ├── データリポジトリ
│   ├── データベース操作
│   └── 外部API連携
└── インフラ層
    ├── 設定管理
    ├── ログ・監視
    └── セキュリティ
```

**デスクトップ・モバイルアプリケーション**:
```
機能分割方針:
├── プレゼンテーション層
│   ├── 画面・ビュー
│   ├── ユーザー操作処理
│   └── 表示制御
├── アプリケーション層
│   ├── ビジネスロジック
│   ├── データ処理
│   └── 外部サービス連携
├── データ層
│   ├── ローカルデータベース
│   ├── ファイル操作
│   └── 設定管理
└── インフラ層
    ├── ネットワーク通信
    ├── セキュリティ
    └── プラットフォーム統合
```

**バッチ・データ処理システム**:
```
機能分割方針:
├── 入力層
│   ├── データ取得
│   ├── ファイル読み込み
│   └── 外部システム連携
├── 処理層
│   ├── データ変換
│   ├── ビジネスロジック実行
│   └── 計算・集計処理
├── 出力層
│   ├── データ出力
│   ├── レポート生成
│   └── 通知・アラート
└── 制御層
    ├── ジョブスケジューリング
    ├── エラーハンドリング
    └── 進捗管理
```

### 1.3. 機能間連携・依存関係
- **上位機能依存**: [この機能が依存する上位機能]
- **下位機能提供**: [この機能が提供する下位機能]
- **外部システム連携**: [連携する外部システム・API]
- **共通機能利用**: [利用する共通機能・ライブラリ]

### 1.4. 非機能要件マッピング
| 要件項目 | 要件値 | 設計方針 | 実装アプローチ |
|----|-----|----|----|
| 応答時間 | [性能要件] | [技術スタック固有の最適化方針] | [具体的実装手法] |
| 同時処理数 | [性能要件] | [並行処理・非同期処理方針] | [技術固有の実装方法] |
| 可用性 | [信頼性要件] | [冗長化・フェイルオーバー方針] | [インフラ・アーキテクチャ対応] |
| セキュリティ | [セキュリティ要件] | [認証・暗号化方針] | [セキュリティ機能実装] |

## 2. アーキテクチャ適応設計

### 2.1. 技術スタック適応
```
技術スタック確認・適応フロー:
1. architecture/system-architecture.md で技術スタックを確認
2. IF 技術スタックが下記「主要技術スタック別アプローチ」に記載済み THEN
     該当技術の推奨構成を適用
   ELSE IF 技術スタックが未記載 THEN
     「未記載技術スタックの適応フロー」に従って公式ドキュメント参照
   END IF
3. フレームワーク・ライブラリの推奨パターンを適用
4. 言語固有のベストプラクティスを反映
```

#### 主要技術スタック別アプローチ

**JavaScript/TypeScript + Node.js**:
```
推奨構成:
src/
├── [feature]/              # 機能別ディレクトリ
│   ├── controllers/        # Web層（Express等）
│   ├── services/           # ビジネスロジック層
│   ├── repositories/       # データアクセス層
│   ├── models/             # データモデル
│   ├── routes/             # ルーティング
│   └── tests/              # テスト
└── shared/                 # 共通機能
```

**Python**:
```
推奨構成:
src/
├── [feature]/              # 機能パッケージ
│   ├── views.py           # Web層（Django/Flask）
│   ├── services.py        # ビジネスロジック
│   ├── repositories.py    # データアクセス
│   ├── models.py          # データモデル
│   ├── urls.py            # URLルーティング
│   └── tests/             # テスト
└── shared/                # 共通パッケージ
```

**Java**:
```
推奨構成:
src/main/java/
└── com/company/project/
    ├── [feature]/          # 機能パッケージ
    │   ├── controller/     # Web層
    │   ├── service/        # ビジネスロジック
    │   ├── repository/     # データアクセス
    │   ├── model/          # エンティティ
    │   └── dto/            # データ転送オブジェクト
    └── shared/             # 共通パッケージ
```

**PHP**:
```
推奨構成:
src/
├── [Feature]/              # 機能名前空間
│   ├── Controllers/        # Web層
│   ├── Services/          # ビジネスロジック
│   ├── Repositories/      # データアクセス
│   ├── Models/            # データモデル
│   └── Tests/             # テスト
└── Shared/                # 共通機能
```

**Go**:
```
推奨構成:
cmd/                       # エントリーポイント
internal/
├── [feature]/             # 機能パッケージ
│   ├── handler/           # HTTP ハンドラー
│   ├── service/           # ビジネスロジック
│   ├── repository/        # データアクセス
│   └── model/             # データ構造
└── shared/                # 共通パッケージ
```

**C#/.NET**:
```
推奨構成:
src/
├── [Feature]/             # 機能プロジェクト
│   ├── Controllers/       # Web API層
│   ├── Services/          # ビジネスロジック
│   ├── Repositories/      # データアクセス
│   ├── Models/            # データモデル
│   └── Tests/             # テスト
└── Shared/                # 共通ライブラリ
```

#### 未記載技術スタックの適応フロー
```
IF 使用技術スタックが上記に記載されていない場合 THEN
    1. 公式ドキュメント確認
       ├── 言語公式サイトのProject Layout/Structure Guide確認
       ├── フレームワーク公式ドキュメントのBest Practices確認
       ├── 公式チュートリアルの推奨構成確認
       └── 公式サンプルプロジェクト構成確認
    
    2. コミュニティベストプラクティス確認
       ├── GitHub上の人気プロジェクト構成調査
       ├── Awesome-[言語名] リストの推奨事項確認
       ├── 言語コミュニティの標準的パターン確認
       └── Stack Overflow等の推奨回答確認
    
    3. 汎用原則適用
       ├── 層分離原則（Presentation, Business, Data）適用
       ├── 単一責任原則に基づくモジュール分割
       ├── 依存関係逆転原則に基づく構成
       └── テスト容易性を考慮した構造
    
    4. 実装指針決定
       ├── 確認した公式推奨事項を最優先
       ├── コミュニティ標準を次点として採用
       ├── 汎用原則で補完
       └── プロジェクト固有要件で調整

ELSE IF 記載済み技術スタックの場合 THEN
    上記推奨構成をベースとして適用
    
END IF
```

### 2.2. プロジェクト固有適応
```
適応手順:
1. 既存プロジェクトの構成パターンを調査
2. プロジェクト固有の命名規則を特定
3. 使用フレームワークの推奨構成を確認
4. チーム固有のコーディング規約を適用
```

### 2.3. 機能別ディレクトリ詳細設計

#### 汎用的なディレクトリ構成原則
```
[機能名]/
├── [入力処理層]/          # リクエスト受付・入力検証
├── [ビジネスロジック層]/    # 業務処理・計算・変換
├── [データアクセス層]/      # データ永続化・外部連携
├── [出力処理層]/          # レスポンス生成・出力処理
├── [モデル・型定義]/       # データ構造・ドメインモデル
├── [共通機能]/            # ユーティリティ・ヘルパー
└── [テスト]/              # 単体・統合テスト
```

#### ファイル命名規則（技術スタック別）
| 技術スタック | クラス/モジュール | ファイル名 | 関数/メソッド |
|----|----|----|----|
| JavaScript/TypeScript | PascalCase | camelCase.js/ts | camelCase |
| Python | PascalCase | snake_case.py | snake_case |
| Java | PascalCase | PascalCase.java | camelCase |
| PHP | PascalCase | PascalCase.php | camelCase |
| Go | PascalCase | snake_case.go | PascalCase(public)/camelCase(private) |
| C# | PascalCase | PascalCase.cs | PascalCase |
| **未記載言語** | **公式Style Guide準拠** | **公式Style Guide準拠** | **公式Style Guide準拠** |

```
未記載言語の命名規則確認手順:
IF 使用言語が上記表に記載されていない場合 THEN
    1. 言語公式Style Guide/Coding Conventionsを確認
    2. 主要フレームワークのStyle Guideを確認  
    3. 言語コミュニティのde facto standardを確認
    4. 確認した規則をプロジェクト全体で一貫適用
END IF
```

## 3. 処理フロー設計

### 3.1. 汎用処理フローパターン

#### 基本処理フロー（アプリケーション種別非依存）
```mermaid
graph TD
    A[入力受付] --> B[入力検証]
    B --> C{検証結果}
    C -->|成功| D[ビジネスロジック実行]
    C -->|失敗| E[エラー応答]
    D --> F[データ操作]
    F --> G[外部システム連携]
    G --> H[結果処理]
    H --> I[出力生成]
    I --> J[応答返却]
    
    D --> K{例外発生}
    K -->|あり| L[例外処理]
    K -->|なし| F
    L --> M[エラーログ出力]
    M --> E
```

#### 非同期処理フロー
```
非同期処理パターン:

1. イベント駆動パターン
   入力 → イベント発行 → 非同期処理 → 結果通知

2. ジョブキューパターン  
   入力 → ジョブエンキュー → バックグラウンド処理 → 状態更新

3. ストリーミングパターン
   データストリーム → 逐次処理 → リアルタイム出力

4. バッチ処理パターン
   スケジュール → データ収集 → 一括処理 → 結果出力
```

### 3.2. 主要処理シーケンス（技術中立）

```
シーケンス: [主要ユースケース名]

操作者 -> 入力層: [操作・要求]
入力層 -> バリデーション層: [入力検証]
バリデーション層 --> 入力層: [検証結果]

alt 検証成功
    入力層 -> ビジネスロジック層: [業務処理要求]
    ビジネスロジック層 -> データアクセス層: [データ操作要求]
    データアクセス層 -> データストア: [データ操作実行]
    データストア --> データアクセス層: [操作結果]
    データアクセス層 --> ビジネスロジック層: [処理結果]
    
    alt 外部システム連携が必要
        ビジネスロジック層 -> 外部連携層: [外部API呼び出し]
        外部連携層 -> 外部システム: [通信]
        外部システム --> 外部連携層: [応答]
        外部連携層 --> ビジネスロジック層: [変換済み結果]
    end
    
    ビジネスロジック層 --> 入力層: [業務処理完了]
    入力層 -> 出力層: [結果出力要求]
    出力層 --> 操作者: [処理結果応答]
else 検証失敗
    入力層 -> 出力層: [エラー出力要求]
    出力層 --> 操作者: [エラー応答]
end
```

### 3.3. エラーハンドリングフロー（汎用）

```
エラー分類・処理フロー:

1. 入力エラー
   ├── バリデーションエラー → ユーザーに修正要求
   ├── 認証エラー → 認証画面へリダイレクト
   └── 認可エラー → アクセス拒否応答

2. ビジネスロジックエラー
   ├── ビジネスルール違反 → ビジネス例外として処理
   ├── データ不整合 → トランザクション巻き戻し
   └── 制約違反 → 制約エラーとして応答

3. インフラエラー  
   ├── データベースエラー → 接続復旧・リトライ
   ├── ネットワークエラー → 通信復旧・リトライ
   └── システムエラー → ログ出力・管理者通知

4. 外部システムエラー
   ├── 一時的エラー → 指数バックオフリトライ
   ├── 永続的エラー → フォールバック処理
   └── タイムアウト → 処理中断・状態保存
```

## 4. データフロー設計

### 4.1. 汎用データアーキテクチャ

```
データフロー階層（技術中立）:

[外部システム] ←→ [外部システムアダプタ]
                          ↓
[データストア] ←→ [データアクセス抽象化層]
                          ↓
[ドメインモデル] ←→ [ビジネスロジック層]
                          ↓
[アプリケーション状態] ←→ [アプリケーション層]
                          ↓
[プレゼンテーション状態] ←→ [プレゼンテーション層]
```

### 4.2. データ状態管理設計

```
状態管理パターン（技術別適応）:

Web フロントエンド:
- 状態管理ライブラリ（Redux, Vuex, MobX等）
- ローカル状態（component state）
- サーバー状態同期（React Query, SWR等）

バックエンド:
- セッション状態（session storage）
- キャッシュ状態（Redis, Memcached等）
- データベース状態（永続化データ）

モバイル:
- アプリケーション状態（MobX, Provider等）
- ローカルストレージ（SQLite, Realm等）
- リモートデータ同期（API通信）

デスクトップ:
- アプリケーション状態（状態管理パターン）
- ローカルファイルシステム
- 設定・構成管理
```

### 4.3. データ変換・マッピング設計

```
データ変換層設計:

1. 入力データ変換
   外部形式 → 内部DTO → ドメインモデル

2. 出力データ変換  
   ドメインモデル → プレゼンテーション DTO → 出力形式

3. 永続化データ変換
   ドメインモデル → データアクセス DTO → ストレージ形式

4. 外部システム連携変換
   内部形式 → 外部API形式 → 外部システム
```

### 4.4. キャッシュ戦略設計

```
キャッシュ戦略（技術別適応）:

アプリケーションレベル:
├── メモリキャッシュ（アプリケーション内）
├── 分散キャッシュ（Redis, Hazelcast等）
├── データベースキャッシュ（クエリキャッシュ）
└── CDN キャッシュ（静的リソース）

キャッシュ制御戦略:
├── TTL（Time To Live）管理
├── 無効化戦略（invalidation）
├── 更新戦略（write-through, write-back）
└── 容量制御（LRU, LFU eviction）
```

## 5. モジュール・コンポーネント設計

### 5.1. モジュール階層設計（技術中立）

```
モジュール階層原則:

高レベルモジュール（ビジネスロジック）
├── 機能モジュール（機能固有処理）
    ├── 汎用モジュール（再利用可能処理）
        ├── 基盤モジュール（技術的処理）

責務分離原則:
├── 単一責任の原則（Single Responsibility）
├── 開放閉鎖の原則（Open/Closed）
├── 依存関係逆転の原則（Dependency Inversion）
└── インターフェース分離の原則（Interface Segregation）
```

### 5.2. 設計パターン適用

#### 技術スタック別推奨パターン

**オブジェクト指向言語（Java, C#, Python等）**:
```
推奨パターン:
├── Factory パターン（オブジェクト生成）
├── Strategy パターン（アルゴリズム選択）
├── Observer パターン（イベント通知）
├── Repository パターン（データアクセス抽象化）
└── Service パターン（ビジネスロジック整理）
```

**関数型言語・パラダイム（JavaScript, Python, Scala等）**:
```
推奨パターン:
├── 高階関数パターン（関数合成）
├── Immutable パターン（不変データ構造）
├── Pipeline パターン（データ変換チェーン）
├── Monad パターン（エラーハンドリング）
└── Functional Composition（関数合成）
```

**Go言語**:
```
推奨パターン:
├── Interface パターン（型安全性）
├── Embedding パターン（コンポジション）
├── Error Handling パターン（エラー処理）
├── Channel パターン（並行処理）
└── Context パターン（リクエストコンテキスト）
```

### 5.3. 再利用性設計

```
再利用性レベル:

1. プロジェクト内再利用
   ├── 共通ユーティリティ
   ├── 汎用データ構造
   └── 共通バリデーション

2. チーム内再利用
   ├── 社内ライブラリ
   ├── 共通フレームワーク
   └── 標準コンポーネント

3. 社外再利用
   ├── オープンソース貢献
   ├── パッケージ公開
   └── プラグイン開発
```

## 6. インターフェース設計

### 6.1. 汎用インターフェース設計原則

```
インターフェース設計原則:

1. 技術中立性
   ├── プロトコル非依存（HTTP, gRPC, messaging等）
   ├── データ形式非依存（JSON, XML, Protocol Buffers等）
   └── 認証方式非依存（Bearer Token, OAuth, API Key等）

2. 契約ファースト設計
   ├── API仕様書優先（OpenAPI, GraphQL Schema等）
   ├── データスキーマ定義（JSON Schema, Protocol Buffers等）
   └── バージョニング戦略（セマンティックバージョニング）

3. 後方互換性
   ├── 非破壊的変更優先
   ├── 段階的移行サポート
   └── レガシー対応
```

### 6.2. API設計（技術別適応）

#### REST API（汎用）
```
エンドポイント設計原則:
- リソース指向設計
- HTTPメソッド適切使用
- ステータスコード標準準拠
- HATEOAS原則適用（必要に応じて）

URL設計パターン:
├── GET /api/v1/[resources]              # 一覧取得
├── GET /api/v1/[resources]/{id}         # 個別取得
├── POST /api/v1/[resources]             # 新規作成
├── PUT /api/v1/[resources]/{id}         # 全体更新
├── PATCH /api/v1/[resources]/{id}       # 部分更新
├── DELETE /api/v1/[resources]/{id}      # 削除
└── POST /api/v1/[resources]/[actions]   # カスタムアクション
```

#### GraphQL API
```
スキーマ設計原則:
- 型安全性重視
- ネストしたデータ効率取得
- リアルタイム更新対応（Subscription）
- 柔軟なクエリ対応

型定義パターン:
├── Query型（データ取得）
├── Mutation型（データ変更）
├── Subscription型（リアルタイム更新）
├── Custom Scalar型（独自データ型）
└── Interface/Union型（ポリモーフィズム）
```

#### gRPC API
```
サービス定義原則:
- Protocol Buffers スキーマ
- 型安全な通信
- ストリーミング対応
- 言語間互換性

サービス設計パターン:
├── Unary RPC（1リクエスト-1レスポンス）
├── Server Streaming（1リクエスト-Nレスポンス）
├── Client Streaming（Nリクエスト-1レスポンス）
└── Bidirectional Streaming（Nリクエスト-Nレスポンス）
```

### 6.3. データベースインターフェース設計

```
データアクセス抽象化設計:

1. Repository パターン
   ├── データアクセス抽象化
   ├── テスト容易性向上
   ├── データソース変更対応
   └── ビジネスロジック分離

2. データマッパーパターン
   ├── オブジェクト-リレーショナルマッピング
   ├── ドメインモデル純粋性保持
   ├── 永続化詳細隠蔽
   └── 複雑なマッピング対応

3. Active Record パターン  
   ├── オブジェクト-データベース統合
   ├── 簡単なCRUD操作
   ├── RAD（Rapid Application Development）対応
   └── プロトタイピング効率性
```

### 6.4. 外部システムインターフェース設計

```
外部システム連携設計:

1. アダプターパターン
   ├── 外部システム差異吸収
   ├── インターフェース統一
   ├── 変更影響局所化
   └── テスト容易性向上

2. サーキットブレーカーパターン
   ├── 障害伝播防止
   ├── 自動復旧機能
   ├── フォールバック処理
   └── システム安定性向上

3. リトライ・バックオフパターン
   ├── 一時的障害対応
   ├── 指数バックオフ
   ├── ジッター追加
   └── 最大試行回数制限
```

## 7. エラーハンドリング設計

### 7.1. 汎用エラー分類・階層設計

```
汎用エラー階層（技術中立）:

ApplicationError（基底）
├── InputError（入力関連）
│   ├── ValidationError（バリデーション）
│   ├── AuthenticationError（認証）
│   └── AuthorizationError（認可）
├── BusinessError（ビジネスロジック）
│   ├── BusinessRuleViolationError（ルール違反）
│   ├── DataConstraintError（データ制約）
│   └── StateTransitionError（状態遷移）
├── InfrastructureError（インフラ）
│   ├── DatabaseError（データベース）
│   ├── NetworkError（ネットワーク）
│   ├── FileSystemError（ファイルシステム）
│   └── ExternalServiceError（外部サービス）
└── SystemError（システム）
    ├── ConfigurationError（設定）
    ├── ResourceExhaustionError（リソース不足）
    └── UnexpectedError（予期しないエラー）
```

### 7.2. エラーハンドリング戦略（技術別）

#### 例外処理型言語（Java, C#, Python等）
```
try-catch-finally パターン:
- 適切な例外型でキャッチ
- リソース確実解放（finally, using等）
- 例外チェーン保持
- ログ詳細記録

例外設計原則:
├── チェック例外 vs ランタイム例外の適切選択
├── 例外安全性保証（基本保証・強保証・例外なし保証）
├── 例外仕様明記（throws, @throws等）
└── カスタム例外適切定義
```

#### エラー型返却言語（Go, Rust等）
```
エラー値パターン:
- エラー型明示的返却
- エラーチェック必須化
- エラーラッピング
- エラーコンテキスト追加

エラー処理原則:
├── エラー無視禁止
├── エラー情報詳細化
├── エラー処理責務明確化
└── エラー伝播制御
```

#### 混合型言語（JavaScript/TypeScript等）
```
Promise/async-await パターン:
- try-catch での非同期エラー処理
- Promise.catch でのエラーハンドリング
- unhandledRejection対策
- Error オブジェクト適切活用

エラー処理戦略:
├── 同期・非同期エラー統一処理
├── エラーバウンダリ設定
├── グローバルエラーハンドラー
└── エラー情報構造化
```

### 7.3. ログ・監視設計

```
ログレベル戦略:
├── FATAL: システム停止レベル
├── ERROR: 機能停止レベル
├── WARN: 注意が必要なレベル
├── INFO: 一般情報レベル
└── DEBUG: デバッグ情報レベル

構造化ログ設計:
├── タイムスタンプ（ISO 8601形式）
├── ログレベル
├── メッセージ
├── コンテキスト情報（リクエストID, ユーザーID等）
├── エラー詳細（スタックトレース等）
└── 追加メタデータ
```

## 8. 性能・セキュリティ設計

### 8.1. 性能設計（技術別最適化）

```
性能最適化戦略（技術スタック別）:

フロントエンド（Web）:
├── バンドルサイズ最適化（Code Splitting, Tree Shaking）
├── レンダリング最適化（Virtual DOM, Memo化）
├── ネットワーク最適化（HTTP/2, CDN, 圧縮）
└── キャッシュ戦略（Browser Cache, Service Worker）

バックエンド（API）:
├── データベースアクセス最適化（インデックス, クエリ最適化）
├── キャッシュ活用（Redis, Memcached, Application Cache）
├── 非同期処理（Non-blocking I/O, Worker Queue）
└── 負荷分散（Load Balancer, Horizontal Scaling）

データベース:
├── クエリ最適化（実行計画, インデックス戦略）
├── データ構造最適化（正規化 vs 非正規化）
├── パーティショニング（Horizontal, Vertical）
└── レプリケーション（Read Replica, Sharding）

モバイル:
├── バッテリー効率最適化（Background Processing制限）
├── メモリ使用量最適化（Object Pooling, Lazy Loading）
├── ネットワーク効率最適化（データ圧縮, 差分更新）
└── UI応答性最適化（Main Thread負荷軽減）
```

### 8.2. セキュリティ設計（汎用）

```
セキュリティ対策レイヤー:

1. ネットワークセキュリティ
   ├── HTTPS/TLS暗号化通信
   ├── ファイアウォール設定
   ├── DDoS攻撃対策
   └── VPN・プライベートネットワーク

2. アプリケーションセキュリティ
   ├── 認証・認可実装
   ├── 入力値検証・サニタイゼーション
   ├── SQLインジェクション対策
   ├── XSS（Cross-Site Scripting）対策
   ├── CSRF（Cross-Site Request Forgery）対策
   └── セッション管理

3. データセキュリティ
   ├── 保存時暗号化（Encryption at Rest）
   ├── 転送時暗号化（Encryption in Transit）
   ├── 個人情報マスキング・匿名化
   ├── アクセス制御（RBAC, ABAC）
   └── データ整合性保証

4. 運用セキュリティ
   ├── セキュリティログ監視
   ├── 脆弱性管理
   ├── セキュリティテスト自動化
   ├── インシデント対応計画
   └── セキュリティ教育・啓蒙
```

### 8.3. 監査・コンプライアンス設計

```
監査機能設計:

1. アクセス監査
   ├── ログイン・ログアウト記録
   ├── 操作履歴追跡
   ├── データアクセス記録
   └── 権限変更履歴

2. データ変更監査
   ├── 作成・更新・削除記録
   ├── 変更前後差分記録
   ├── 操作者特定情報
   └── タイムスタンプ記録

3. システム監査
   ├── システム設定変更記録
   ├── セキュリティイベント記録
   ├── エラー・例外発生記録
   └── パフォーマンス記録
```

## 9. テスト設計

### 9.1. テスト戦略（技術中立）

```
テストピラミッド（汎用）:

E2E Tests（少数・高コスト・高価値）
├── ユーザーシナリオテスト
├── システム統合テスト
└── 受け入れテスト

Integration Tests（中程度・中コスト・中価値）
├── API統合テスト
├── データベース統合テスト
├── 外部サービス統合テスト
└── モジュール間統合テスト

Unit Tests（多数・低コスト・即座フィードバック）
├── 関数・メソッド単体テスト
├── クラス単体テスト
├── モジュール単体テスト
└── ユーティリティテスト

テストカバレッジ目標（推奨）:
├── ライン カバレッジ: 80%以上
├── ブランチ カバレッジ: 70%以上
├── 関数カバレッジ: 90%以上
└── クリティカルパス: 100%
```

### 9.2. テスト実装戦略（技術別）

#### JavaScript/TypeScript
```
推奨テストツール:
├── Jest（単体・統合テスト）
├── Cypress/Playwright（E2Eテスト）
├── Testing Library（コンポーネントテスト）
└── MSW（API モック）

テストパターン:
├── AAA（Arrange-Act-Assert）パターン
├── Given-When-Then パターン
├── Test Doubles（Mock, Stub, Fake）
└── Property-based Testing
```

#### Python
```
推奨テストツール:
├── pytest（単体・統合テスト）
├── unittest（標準ライブラリ）
├── Selenium（E2Eテスト）
└── responses/httpx（HTTP モック）

テストパターン:
├── Fixture活用（setup/teardown）
├── Parametrized Testing（パラメータ化テスト）
├── Mock/Patch活用
└── Hypothesis（Property-based Testing）
```

#### Java
```
推奨テストツール:
├── JUnit 5（単体テスト）
├── Mockito（モックフレームワーク）
├── Testcontainers（統合テスト）
└── Selenium/WebDriver（E2Eテスト）

テストパターン:
├── Test Lifecycle（@BeforeEach, @AfterEach等）
├── Parameterized Tests
├── Test Doubles（@Mock, @Spy等）
└── Behavior Driven Development（Cucumber等）
```

#### Go
```
推奨テストツール:
├── testing（標準パッケージ）
├── Testify（アサーション・モック）
├── httptest（HTTP テスト）
└── Ginkgo/Gomega（BDDスタイル）

テストパターン:
├── Table-driven Tests
├── Benchmark Tests
├── Example Tests（ドキュメント兼用）
└── Race Condition Tests
```

### 9.3. テストデータ管理

```
テストデータ戦略:

1. テストデータ生成
   ├── Factory Pattern（オブジェクト生成）
   ├── Builder Pattern（複雑オブジェクト構築）
   ├── Fixture Files（静的データ）
   └── Random Data Generation（ランダムデータ）

2. テストデータ分離
   ├── Database Transaction Rollback
   ├── In-Memory Database（H2, SQLite等）
   ├── Test Containers（Docker活用）
   └── Database Seeding/Cleanup

3. モック・スタブ戦略
   ├── External API Mock（外部API模擬）
   ├── Database Mock（データベース模擬）
   ├── File System Mock（ファイルシステム模擬）
   └── Time Mock（時刻制御）
```

## 10. 実装ガイドライン

### 10.1. 開発フロー（技術中立）

```
開発フロー標準:

1. 設計レビュー・準備
   ├── 要件定義・アーキテクチャ設計書確認
   ├── 機能詳細設計書レビュー
   ├── 技術スタック・ツール確認
   └── 開発環境構築

2. 実装順序（推奨）
   ├── ドメインモデル・データ構造定義
   ├── データアクセス層実装
   ├── ビジネスロジック層実装
   ├── アプリケーション層・API実装
   └── プレゼンテーション層・UI実装

3. テスト実装
   ├── 単体テスト（実装と並行）
   ├── 統合テスト（モジュール完成後）
   ├── E2Eテスト（機能完成後）
   └── 手動テスト・探索的テスト

4. 品質確認
   ├── コードレビュー（プルリクエスト）
   ├── 静的解析（リンター、型チェック等）
   ├── 動的テスト（機能・性能・セキュリティ）
   └── ドキュメント更新
```

### 10.2. コード品質基準（汎用）

```
コード品質原則:

1. 可読性
   ├── 意味のある命名（関数、変数、クラス等）
   ├── 適切なコメント（なぜを説明）
   ├── 一貫したコーディングスタイル
   └── 適切な抽象化レベル

2. 保守性
   ├── DRY原則（Don't Repeat Yourself）
   ├── SOLID原則（オブジェクト指向設計）
   ├── 疎結合・高凝集
   └── 明確な責務分離

3. テスト容易性
   ├── 依存性注入（Dependency Injection）
   ├── Pure Functions（副作用最小化）
   ├── モック・スタブ可能設計
   └── テストデータ分離

4. 性能効率性
   ├── アルゴリズム効率性
   ├── メモリ使用量最適化
   ├── I/O効率化
   └── キャッシュ活用
```

### 10.3. セキュリティ実装ガイドライン

```
セキュリティコーディング原則:

1. 入力検証
   ├── すべての入力値検証（Validation）
   ├── サニタイゼーション（有害文字除去）
   ├── ホワイトリスト方式採用
   └── エンコーディング適切処理

2. 認証・認可
   ├── 強力な認証機構実装
   ├── 最小権限の原則適用
   ├── セッション管理適切実装
   └── 認可チェック漏れ防止

3. データ保護
   ├── 機密情報暗号化
   ├── 安全な鍵管理
   ├── データ送信時暗号化
   └── ログ機密情報除外

4. エラーハンドリング
   ├── エラー情報漏洩防止
   ├── 適切なエラーメッセージ
   ├── セキュリティログ出力
   └── 攻撃試行検知・対応
```

### 10.4. パフォーマンス実装ガイドライン

```
パフォーマンス最適化原則:

1. データ処理最適化
   ├── 適切なデータ構造選択
   ├── アルゴリズム計算量最適化
   ├── バッチ処理活用
   └── 並列処理適用

2. I/O最適化
   ├── データベース・クエリ最適化
   ├── ファイルI/O最適化
   ├── ネットワーク通信最適化
   └── キャッシュ活用

3. メモリ管理
   ├── メモリリーク防止
   ├── オブジェクト生成最小化
   ├── ガベージコレクション配慮
   └── 適切なデータ構造選択

4. 非同期処理
   ├── 適切な非同期パターン選択
   ├── スレッドプール活用
   ├── 非ブロッキングI/O活用
   └── リソース競合回避
```

---

## 付録

### A. 技術スタック別参考資料

#### フレームワーク・ライブラリ固有考慮事項
```
IF 技術スタックが記載済み（JavaScript/TypeScript, Python, Java, PHP, Go, C#）THEN
    各技術の推奨構成・パターンを適用
ELSE IF 技術スタックが未記載 THEN
    以下の公式情報源を順次確認:
    
    1. 言語公式ドキュメント確認
       ├── [言語名] Official Documentation
       ├── [言語名] Style Guide / Coding Conventions
       ├── [言語名] Project Structure / Layout Guide
       └── [言語名] Best Practices Documentation
    
    2. フレームワーク公式情報確認
       ├── [フレームワーク名] Official Documentation
       ├── [フレームワーク名] Getting Started / Tutorial
       ├── [フレームワーク名] Project Structure Guide
       └── [フレームワーク名] Best Practices / Conventions
    
    3. 信頼できるコミュニティ情報確認
       ├── GitHub Awesome-[言語名] リスト
       ├── 言語公式コミュニティ推奨事項
       ├── 主要OSSプロジェクトの構成参考
       └── Stack Overflow高評価回答
    
    4. 確認・適用原則
       ├── 公式情報を最優先で採用
       ├── コミュニティ標準を次点で参考
       ├── 複数の情報源で一致する事項を採用
       └── 不明確な場合は汎用原則で補完
END IF
```

#### バージョン・環境固有考慮事項
- **バージョン固有の制約・推奨事項確認**
- **ランタイム・実行環境の推奨構成確認**
- **依存関係管理の言語別ベストプラクティス確認**

#### 設計書間連携参照
- **architecture/system-architecture.md**: 技術方針・技術スタック確認
- **architecture/data-models.md**: データモデル・データベース設計確認
- **requirements/requirements.md**: 機能・非機能要件確認
- **standards/**: 品質基準・コーディング規約確認

### B. 品質チェックリスト

#### 設計品質確認
- [ ] **設計前情報確認が完了している**
  - [ ] 必要情報チェックリスト（0.1）の確認が完了している
  - [ ] 情報不足時の対応フロー（0.2）が適切に実施されている
  - [ ] 人間への判断委任が適切に行われている（自動的な推測・仮定なし）
  - [ ] 人間からの明確な承認・指示を得てから設計継続している
- [ ] 技術スタックに適したアーキテクチャパターンを採用している
- [ ] 要件定義の全機能要件が設計に反映されている
- [ ] 非機能要件（性能・セキュリティ等）が適切に考慮されている
- [ ] テスト可能な設計となっている
- [ ] 保守・拡張性が考慮されている
- [ ] **未記載言語の場合**: 公式ドキュメント・ベストプラクティスに準拠している

#### 実装品質確認
- [ ] コーディング規約に準拠している
- [ ] セキュリティ要件が満たされている
- [ ] パフォーマンス要件が満たされている
- [ ] エラーハンドリングが適切に実装されている
- [ ] ログ・監視が適切に実装されている
- [ ] **未記載言語の場合**: 言語固有のStyle Guide・Conventionsに準拠している

#### 文書品質確認
- [ ] 実装チームが理解・実装可能な詳細度である
- [ ] 技術スタックに応じた具体的な指針がある
- [ ] 設計判断の根拠・理由が明確である
- [ ] 将来の保守・拡張を考慮した設計である
- [ ] プロジェクト固有の制約・要件が反映されている
- [ ] **情報不足時の対応が適切である**
  - [ ] 人間への判断委任が適切に実施されている
  - [ ] 人間承認済み事項が明確に記載されている（承認日時・承認者含む）
  - [ ] 承認済み仮定条件が根拠と共に明記されている
  - [ ] 要確認事項が依然として明確に記載されている
  - [ ] リスク・懸念事項が適切に評価・記載されている
- [ ] **未記載言語の場合**: 公式ドキュメント参照結果が明記されている

---

## 汎用機能詳細設計書作成ガイドライン

### 汎用設計の観点
1. **情報完全性**: 設計前情報確認による要件・技術要件の完全把握（不足時は人間に判断委任）
2. **技術中立性**: 特定技術スタックに依存しない設計原則・パターン
3. **適応性**: プロジェクト固有技術スタックへの適応機構
4. **拡張性**: 新技術・新要件への対応可能性
5. **実装可能性**: 開発チームが直接実装できる具体性・実現可能性
6. **品質特性**: 非機能要件の技術別実装指針

### 技術適応設計方針
- **情報確認**: 設計前情報確認（セクション0）を最初に実施
- **情報不足時**: 人間に判断委任、AI独自判断での推測・仮定は禁止
- **技術調査**: architecture/system-architecture.md で技術スタック確認
- **記載技術の場合**: 推奨構成・パターンを直接適用
- **未記載技術の場合**: 公式ドキュメント・ベストプラクティスを優先参照
- **パターン適用**: 確認された技術の標準的パターン・ベストプラクティス適用
- **制約考慮**: 技術固有の制約・特性を設計に反映
- **品質保証**: 技術特性に応じた品質保証手法適用

### アーキテクチャ連携重視
- **技術方針継承**: アーキテクチャ設計書の技術選択を詳細設計に適用
- **設計整合性**: データモデル設計・要件定義との整合性確保
- **標準準拠**: プロジェクト・組織の開発標準準拠

常に設計前情報確認（セクション0）を最初に実施し、情報不足時は人間に判断を委ねること。
AIが独自判断で仮定・推測・調査を進めることは禁止。必ず人間の承認を得ること。
常に日本語で記述し、技術スタック確認後の適応的詳細設計を提供すること。
記載済み技術は推奨構成を直接適用し、未記載技術は公式ドキュメント参照により対応すること。
どの技術スタックでも AIが迷わず実装できる汎用的だが具体的な設計指針とすること。
